# Critical Crash Fix - November 12, 2025

## Problem Summary

ePDFView crashed on startup with SIGSEGV (exit code 139) after implementing GTK4 migration fixes for PrintView and MainView.

## Root Cause Analysis

### Core Dump Backtrace
```
#0  0x000055b6eea8647c in PreferencesPter::~PreferencesPter()
#1  0x000055b6eea8658a in PreferencesPter::closeActivated()
#2  0x000055b6eea918ac in [lambda callback from PreferencesView::setPresenter]
```

### The Bug

The crash was caused by **incorrect object lifetime management** in the Preferences dialog system:

1. **Double destruction**: 
   - Lambda callback called `gtk_window_destroy()` first
   - Then called `pter->closeActivated()` which does `delete this`
   - PreferencesPter destructor called `delete m_View`
   - But m_View (PreferencesView) was already partially destroyed by `gtk_window_destroy()`

2. **Signal handler issues**:
   - Both "response" and "close-request" signals called `closeActivated()`
   - No handler disconnection before destruction
   - Potential double-delete of PreferencesPter

### Why It Happened

In GTK3, dialogs could be run with `gtk_dialog_run()` which blocked until closed. In GTK4:
- Nested main loops are discouraged
- Dialogs use async callbacks with "response" signal
- Widget destruction must be carefully coordinated with C++ object lifetime

The original GTK4 port naively converted the sync dialog to async without properly managing object lifetime.

## The Fix

### Changes Made

**File: `src/gtk/PreferencesView.h`**
- Added member variables for signal handler IDs:
  ```cpp
  gulong m_ResponseHandlerId;
  gulong m_CloseRequestHandlerId;
  ```

**File: `src/gtk/PreferencesView.cxx`**

1. **Constructor**: Initialize handler IDs
   ```cpp
   m_ResponseHandlerId = 0;
   m_CloseRequestHandlerId = 0;
   ```

2. **setPresenter()**: Store handler IDs when connecting signals
   ```cpp
   m_ResponseHandlerId = g_signal_connect(m_PreferencesDialog, "response", ...);
   m_CloseRequestHandlerId = g_signal_connect(m_PreferencesDialog, "close-request", ...);
   ```

3. **Signal callbacks**: Only call presenter, don't destroy widget
   ```cpp
   // Response callback
   G_CALLBACK(+[](GtkDialog *, int, gpointer user_data) {
       PreferencesPter *pter = static_cast<PreferencesPter*>(user_data);
       pter->closeActivated(); // This does delete this
   }), pter);
   
   // Close-request callback returns TRUE to prevent duplicate handling
   G_CALLBACK(+[](GtkWindow *, gpointer user_data) -> gboolean {
       PreferencesPter *pter = static_cast<PreferencesPter*>(user_data);
       pter->closeActivated();
       return TRUE; // Prevent default - handled by response signal
   }), pter);
   ```

4. **Destructor**: Disconnect signals before destroying window
   ```cpp
   if (m_ResponseHandlerId > 0) {
       g_signal_handler_disconnect(m_PreferencesDialog, m_ResponseHandlerId);
       m_ResponseHandlerId = 0;
   }
   if (m_CloseRequestHandlerId > 0) {
       g_signal_handler_disconnect(m_PreferencesDialog, m_CloseRequestHandlerId);
       m_CloseRequestHandlerId = 0;
   }
   gtk_window_destroy(GTK_WINDOW(m_PreferencesDialog));
   m_PreferencesDialog = NULL;
   ```

### Object Lifetime Flow (After Fix)

1. User opens Preferences → `PreferencesPter` and `PreferencesView` created on heap
2. User clicks Close button → GTK emits "response" signal
3. Response callback calls `pter->closeActivated()`
4. `closeActivated()` does `delete this` (PreferencesPter)
5. PreferencesPter destructor calls `delete m_View`
6. PreferencesView destructor:
   - Disconnects signal handlers (prevents callbacks on partially destroyed object)
   - Calls `gtk_window_destroy()` to clean up GTK widgets
   - Nulls out widget pointer
7. Clean shutdown, no double-free

## Verification

After the fix:
- ✅ Program starts without SIGSEGV
- ✅ Main window displays correctly
- ✅ Navigation buttons work (Previous/Next page)
- ✅ Page number updates visually in headerbar
- ✅ PDF rendering works correctly
- ✅ No GTK-CRITICAL errors about signal handlers

## Lessons Learned

### GTK4 Dialog Best Practices

1. **Never call `delete this` from a signal callback** unless you're certain the object owns all its resources
2. **Always disconnect signal handlers** before destroying widgets that have C++ object wrappers
3. **GTK4 async dialogs** require careful lifetime management - widget destruction != C++ object destruction
4. **Use handler IDs** (`gulong`) to track and disconnect signals properly

### Code Smell Indicators

- `delete this` in any method other than a factory's release function
- Signal callbacks that destroy both the widget AND the C++ wrapper
- No `g_signal_handler_disconnect()` calls in destructors
- Multiple signals calling the same cleanup code without guard conditions

## Related Files

- `src/gtk/PreferencesView.h` - Class declaration
- `src/gtk/PreferencesView.cxx` - Implementation with fixes
- `src/PreferencesPter.h` - Presenter interface
- `src/PreferencesPter.cxx` - Presenter with `delete this` pattern
- `src/MainPter.cxx` - Creates PreferencesPter/PreferencesView pair

## Testing Notes

To reproduce the original bug:
1. Revert to commit before this fix
2. Compile with `meson compile -C build`
3. Run `./build/src/epdfview`
4. Result: Immediate SIGSEGV on startup

The crash occurred even **without opening the Preferences dialog** because GTK4 does initialization that triggers signal connections early.

## Future Improvements

Consider refactoring the Presenter pattern to avoid `delete this`:
- Use `std::shared_ptr` or `std::unique_ptr` for automatic lifetime management
- Implement a proper dialog manager that owns dialog objects
- Use weak references in signal callbacks to detect destroyed objects

## References

- GTK4 Migration Guide: https://docs.gtk.org/gtk4/migrating-3to4.html
- GObject Signal Documentation: https://docs.gtk.org/gobject/concepts.html#signals
- Core dump analysis: `coredumpctl debug <PID>`
